import matplotlib as plt
import numpy as np

BETZ = 0.35
GENEFF = 0.85
CVTEFF = 0.85
IDEALTSR = 2 # small widnd turbines
# create simulated fluctuations of wind data for testing
# NOTE RESSHAPE EQUATIONS TO OPTIMIZE FOR TSR, NOT RPMA   
# tsr = w*R / V

# simulate wind fluctuations
# this assumes a minute 
def createWind(wind, n):
  windList = []
  for i in range(n):
    windList.append(
      wind +
      2 * np.pi * (2 * np.pi * i / 120) +
      1 * np.pi * (2 * np.pi * i / 30) +
      0.5 * np.random.randn(n)
    )

  print(windList)
  return windList

# we use a tsr based approach
# what we do is calculate tsr, make ideal gear ratio to match from tsr 
# then "tilt" the shift to know how much to shift for that
# also place a treshhold so we dont shift all the time
# calculate current gear ratio, return ideal and power output from electricity
def shifterDriver(power, rpm, speed, dimensions, config):
  gearRatio = 1
  # input radius of torroidal cvt discs
  rinput = dimensions.input
  routput = dimensions.output
  # torus shifter, it adjusts angle to change radius
  theta = 0

  # upper and lower gear ratios, given from vawtgearratio
  lower = config.lower
  upper = config.upper

  # ideal rpm
  ideal = config.genv
  rotationalspeed = rpm * 2 * np.pi /60
  currenttsr = rotationalspeed * dimensions.r / v
  gearRatio = routput / rinput
  
  # calculates ideal gear ratio to upkeep ideal tsr of 2
  idealgr = gearRatio * IDEALTSR / currenttsr

  # if difference between the two gear ratios are greater than 1, shift 
  # ensures that it doesnt shift all the time and yadda yadda
  if (idealgr - gearRatio > 1):
    # shift the gear
    # insert magic formula that determines theta by difference of the two gear ratios
    theta = 0

    # linear map
    def mapfunc(x, xmin, xmax):
      return 90 * (x - xmin) / (xmax - xmin)

    # make sure it doesnt go beyond radius or the gear ratio bounds
    # get theta based on a linearly mapped values between lower and upper
    # for example, 45deg is the median value
    theta = mapfunc(gearRatio, lower, upper)

    # translate theta change back to gear ratio
    # i mean, if a radius value maps to a theta value, cant we just linmap it again?
    # of course, theres also the option of just returning the idgr

    gearRatio = idealgr
    print(f'>> SHIFTED TURBINE TO {gearRatio}, ROLLER ANGLED AT {theta} DEGREE')

  # given this, i want to recalculate power at that moment
  # torque of turbine at that moment
  torque = power / speed
  genspeed = speed / gearRatio
  gentorque = torque * gearRatio * GENEFF

  # this is what we want
  genpower = gentorque * genspeed

  print('>> METRICS --------------')
  return {
    'power': genpower, # electrical power generated,
    'ratio': gearRatio
  }

def simulate(windList, dimensions, config):
  # waahahh
  # hi
  # metrics to calculate
  # - power
  # - rpm at that moment
  # - torque 
  # inertia = 101.28kg * m^2, obtain from fusion simulations
  angularaccel = 0
  angularvelo = 0
  for i in windList:
    # power is power from wind - power from inertia
    # inertia is defined by moment of inertia * angular accel * angular velocity
    omega = angularvelo # past angular velo
    rpm = (IDEALTSR * i * 60) / (2 * np.pi * dimensions.diam/2)
    powofinertia = 101.28 * angularaccel * angularvelo
    torque = 0.5 * config.d * (dimensions.diam * dimensions.hei) * i**3 
    power = torque * BETZ
    # delta angular velo / delta time
    angularvelo = rpm / 60 * 2 * np.pi
    angularaccel = (angularvelo - omega) / (1) # convert to seconds because why tf not
    netpow = power - powofinertia
    epower = shifterDriver(netpow, rpm, angularvelo, dimensions, config)

  metrics = {
    'pow': netpow,
    'epow': epower.power,
    'ratio': epower.ratio,
    'genrpm': rpm * epower.ratio
  }
  visualize(windList, metrics)


def visualize(wind, metrics):
  # time series
  x = list(range(len(wind)))
  plt.plot(x, wind, label='TIME VS WIND')
  plt.plot(x, metrics.power, label='TIME VS POWER GENERATION')
  plt.plot(x, metrics.genrpm, label='TIME VS RPM')
  plt.plot(x, metrics.ratio, label='GEAR RATIO')

def main():
  # only if no provided wind data
  print('>> WINDSPEED ----------------')
  print('READING FILE FOR DATA')
  data = 0 # get file 
  if (data is None or data == 0):
    print('FILE UNABLE TO BE READ, DEFAULTING.')
    w = int(input('WINDSPEED: '))
    d = int(input('NUMBER OF DATAPOINTS: '))
    data = createWind(w, d)

  print('>> DIMENSIONS ---------------')
  diameter = float(input('TURBINE DIAMETER: '))
  height = float(input('TURBINE HEIGHT: '))
  chordthickness = float(input('CHORD THICKNESS: '))
  chordlen = float(input('CHORD LENGTH: '))
  dimen = {
    'diam': diameter, 
    'hei': height,
    'ct': chordthickness,
    'cl': chordlen
  }

  print('>> CONFIG -------------------')
  inf = int(input('CONTINUOUS RUN: '))
  den = float(input('AIR DENSITY: '))
  genspeed = int(input('GENERATOR RATED RPM: '))
  inertia = float(input('MOMENT OF INERTIA OF TURBINE: '))
  lower = float(input('LOWER GEAR RATIO: '))
  upper = float(input('UPPER GEAR RATIO: '))

  conf = {
    'infinite': inf,
    'density': den,
    'genv': genspeed,
    'lowerbound': lower,
    'upperbound': upper,
    'inertia': inertia,
  }
  simulate(data, dimen, conf)

if __name__ == '__main__':
  main()